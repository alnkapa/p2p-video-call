<!DOCTYPE html>
<html lang="en">
  <body>
    <div class="container">
      <h3>–ê–ª–∏—Å–∞: –ò–Ω–∏—Ü–∏–∞—Ç–æ—Ä —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è</h3>

      <button onclick="startConnection()">üé§ –ù–∞—á–∞—Ç—å –∑–≤–æ–Ω–æ–∫</button>

      <div id="status">–°—Ç–∞—Ç—É—Å: –û–∂–∏–¥–∞–Ω–∏–µ...</div>

      <!-- –î–æ–±–∞–≤–ª–µ–Ω—ã –≤–∏–¥–µ–æ —ç–ª–µ–º–µ–Ω—Ç—ã -->
      <div style="display: flex; gap: 20px; margin: 20px 0">
        <div>
          <h4>–í–∞—à–µ –≤–∏–¥–µ–æ:</h4>
          <video
            id="localVideo"
            autoplay
            muted
            playsinline
            style="width: 300px; height: 225px; background: #000"
          ></video>
        </div>
        <div>
          <h4>–í–∏–¥–µ–æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞:</h4>
          <video
            id="remoteVideo"
            autoplay
            playsinline
            style="width: 300px; height: 225px; background: #000"
          ></video>
        </div>
      </div>

      <textarea
        id="sdpOffer"
        readonly
        placeholder="SDP –æ—Ñ—Ñ–µ—Ä –ø–æ—è–≤–∏—Ç—Å—è –∑–¥–µ—Å—å..."
      ></textarea>
      <button onclick="copyCompressedOffer()" id="copyBtn" disabled>
        üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å SDP –æ—Ñ—Ñ–µ—Ä
      </button>

      <textarea
        id="sdpAnswer"
        placeholder="–í—Å—Ç–∞–≤—å—Ç–µ —Å—é–¥–∞ SDP answer –æ—Ç –ë–æ–±–∞..."
      ></textarea>
      <button onclick="pasteCompressedAnswer()">‚úÖ –ü—Ä–∏–º–µ–Ω–∏—Ç—å SDP answer</button>

      <div id="connectionStatus"></div>
    </div>

    <script>
      class SDPCompressor {
        // –°–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏ —Å–∂–∞—Ç–∏–µ SDP
        static async compressSDP(sdpData) {
          try {
            // –ü—Ä–æ–±—É–µ–º —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–µ API —Å–∂–∞—Ç–∏—è
            if (window.CompressionStream) {
              const encoded = new TextEncoder().encode(sdpData);

              // –°–æ–∑–¥–∞–µ–º ReadableStream –∏–∑ Uint8Array
              const readableStream = new ReadableStream({
                start(controller) {
                  controller.enqueue(encoded);
                  controller.close();
                },
              });

              const cs = new CompressionStream("deflate");
              const compressedStream = readableStream.pipeThrough(cs);

              const chunks = [];
              const reader = compressedStream.getReader();
              while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                chunks.push(value);
              }

              const compressedBlob = new Blob(chunks);
              const base64 = await this.blobToBase64(compressedBlob);
              return `compressed:${base64}`;
            }
          } catch (err) {
            console.warn("CompressionStream –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è:", err);
          }

          // Fallback: –ø—Ä–æ—Å—Ç–æ Base64
          const base64 = btoa(unescape(encodeURIComponent(sdpData)));
          return `base64:${base64}`;
        }

        // –†–∞—Å–ø–∞–∫–æ–≤–∫–∞ –∏ –¥–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è
        static async decompressSDP(compressedData) {
          if (compressedData.startsWith("compressed:")) {
            try {
              const base64 = compressedData.slice(11);
              const blob = await this.base64ToBlob(base64);

              const ds = new DecompressionStream("deflate");
              const decompressedStream = blob.stream().pipeThrough(ds);

              const chunks = [];
              const reader = decompressedStream.getReader();
              while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                chunks.push(value);
              }

              const array = new Uint8Array(
                await new Blob(chunks).arrayBuffer()
              );
              return new TextDecoder().decode(array);
            } catch (err) {
              console.warn("–û—à–∏–±–∫–∞ —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∏:", err);
            }
          }

          // Fallback: Base64
          if (compressedData.startsWith("base64:")) {
            const base64 = compressedData.slice(7);
            return decodeURIComponent(escape(atob(base64)));
          }

          // –ï—Å–ª–∏ –Ω–µ —Å–∂–∞—Ç–æ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–∞–∫ –µ—Å—Ç—å
          return compressedData;
        }

        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
        static blobToBase64(blob) {
          return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result.split(",")[1]);
            reader.readAsDataURL(blob);
          });
        }

        static base64ToBlob(base64) {
          const binary = atob(base64);
          const array = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i++) {
            array[i] = binary.charCodeAt(i);
          }
          return new Blob([array]);
        }
      }

      let peerConnection;
      let localStream;
      let localCandidates = [];
      let resolveFunction;
      let rejectFunction;

      const promise = new Promise((resolve, reject) => {
        resolveFunction = resolve;
        rejectFunction = reject;
      });

      async function startConnection() {
        console.log("üü¢ –ù–∞—á–∏–Ω–∞–µ–º —É—Å—Ç–∞–Ω–æ–≤–∫—É —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è...");
        document.getElementById("status").textContent =
          "üïê –°–æ–∑–¥–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ...";

        try {
          const config = {
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
            ],
            iceCandidatePoolSize: 10,
          };

          peerConnection = new RTCPeerConnection(config);
          console.log("‚úÖ RTCPeerConnection —Å–æ–∑–¥–∞–Ω");

          try {
            localStream = await navigator.mediaDevices.getUserMedia({
              video: true,
              audio: true,
            });

            const localVideo = document.getElementById("localVideo");
            localVideo.srcObject = localStream;

            localStream.getTracks().forEach((track) => {
              peerConnection.addTrack(track, localStream);
            });
            console.log("‚úÖ –ú–µ–¥–∏–∞-–ø–æ—Ç–æ–∫ –ø–æ–ª—É—á–µ–Ω –∏ –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ");
          } catch (err) {
            console.log("‚ö†Ô∏è –ú–∏–∫—Ä–æ—Ñ–æ–Ω/–∫–∞–º–µ—Ä–∞ –Ω–µ –¥–æ—Å—Ç—É–ø–Ω—ã: ", err);
            document.getElementById("status").textContent =
              "‚ö†Ô∏è –ö–∞–º–µ—Ä–∞/–º–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ –¥–æ—Å—Ç—É–ø–Ω—ã, –Ω–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –±—É–¥–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ";
          }

          // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
          await setupConnectionHandlers(resolveFunction);

          // –°–æ–∑–¥–∞–µ–º –æ—Ñ—Ñ–µ—Ä
          await createAndDisplayOffer();
        } catch (err) {
          console.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è:", err);
          document.getElementById("status").textContent =
            "‚ùå –û—à–∏–±–∫–∞: " + err.message;
        }
      }

      async function setupConnectionHandlers(resolveFunction) {
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ ICE –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
        peerConnection.onicecandidate = (event) => {
          console.log("üü° onicecandidate –≤—ã–∑–≤–∞–Ω:", event.candidate);
          if (event.candidate) {
            localCandidates.push(event.candidate);
            document.getElementById(
              "status"
            ).textContent = `üïê –°–æ–±–∏—Ä–∞–µ–º —Å–µ—Ç–µ–≤—ã–µ –∞–¥—Ä–µ—Å–∞... (${localCandidates.length} –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤)`;
            console.log("–ö–∞–Ω–¥–∏–¥–∞—Ç:", event.candidate.toJSON());
          } else {
            console.log("‚úÖ –í—Å–µ ICE –∫–∞–Ω–¥–∏–¥–∞—Ç—ã —Å–æ–±—Ä–∞–Ω—ã");
            document.getElementById(
              "status"
            ).textContent = `‚úÖ –í—Å–µ —Å–µ—Ç–µ–≤—ã–µ –∞–¥—Ä–µ—Å–∞ –≥–æ—Ç–æ–≤—ã! (${localCandidates.length} –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤)`;
            resolveFunction();
          }
        };

        peerConnection.onicecandidateerror = (event) => {
          console.error("‚ùå –û—à–∏–±–∫–∞ ICE –∫–∞–Ω–¥–∏–¥–∞—Ç–∞:", event);
        };

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—Ö–æ–¥—è—â–µ–≥–æ –º–µ–¥–∏–∞-–ø–æ—Ç–æ–∫–∞
        peerConnection.ontrack = (event) => {
          console.log("‚úÖ –í—Ö–æ–¥—è—â–∏–π –º–µ–¥–∏–∞-–ø–æ—Ç–æ–∫ –ø–æ–ª—É—á–µ–Ω:", event);
          const remoteVideo = document.getElementById("remoteVideo");

          if (event.streams && event.streams[0]) {
            remoteVideo.srcObject = event.streams[0];
          } else {
            // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –ø–æ—Ç–æ–∫ –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
            const newStream = new MediaStream();
            newStream.addTrack(event.track);
            remoteVideo.srcObject = newStream;
          }

          document.getElementById("connectionStatus").innerHTML +=
            "<p>‚úÖ –í–∏–¥–µ–æ –æ—Ç —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ –ø–æ–ª—É—á–µ–Ω–æ!</p>";
        };

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        peerConnection.oniceconnectionstatechange = () => {
          const state = peerConnection.iceConnectionState;
          console.log("ICE —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ:", state);
          const statusElem = document.getElementById("connectionStatus");

          if (state === "connected" || state === "completed") {
            statusElem.innerHTML += "<p>‚úÖ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ!</p>";
          } else if (state === "failed") {
            statusElem.innerHTML += "<p>‚ùå –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å</p>";
          } else if (state === "disconnected") {
            statusElem.innerHTML += "<p>‚ö†Ô∏è –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø—Ä–µ—Ä–≤–∞–Ω–æ</p>";
          }
        };

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–∏
        peerConnection.onsignalingstatechange = () => {
          console.log("Signaling state:", peerConnection.signalingState);
        };
      }

      async function createAndDisplayOffer() {
        try {
          console.log("üü° –°–æ–∑–¥–∞–µ–º –æ—Ñ—Ñ–µ—Ä...");

          // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å –ª–æ–∫–∞–ª—å–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ
          if (!peerConnection.currentLocalDescription) {
            const offer = await peerConnection.createOffer();
            console.log("‚úÖ –û—Ñ—Ñ–µ—Ä —Å–æ–∑–¥–∞–Ω");
            await peerConnection.setLocalDescription(offer);
            console.log("‚úÖ Local description —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
          }
          await promise;
          displayCurrentOffer();
        } catch (err) {
          console.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –æ—Ñ—Ñ–µ—Ä–∞:", err);
          document.getElementById("status").textContent =
            "‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –æ—Ñ—Ñ–µ—Ä–∞";
        }
      }

      function displayCurrentOffer() {
        const currentSdp = peerConnection.localDescription.sdp;
        document.getElementById("sdpOffer").value = currentSdp;
        document.getElementById("copyBtn").disabled = false;

        document.getElementById(
          "connectionStatus"
        ).innerHTML = `<p>üì§ SDP –æ—Ñ—Ñ–µ—Ä –≥–æ—Ç–æ–≤! (${localCandidates.length} ICE –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤)</p>
                       <p>–°–∫–æ–ø–∏—Ä—É–π—Ç–µ –µ–≥–æ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –ë–æ–±—É —á–µ—Ä–µ–∑ Telegram</p>`;

        console.log("‚úÖ SDP –æ—Ñ—Ñ–µ—Ä –æ—Ç–æ–±—Ä–∞–∂–µ–Ω");
      }

      async function copyCompressedOffer() {
        try {
          const originalSDP = document.getElementById("sdpOffer").value;
          const compressed = await SDPCompressor.compressSDP(originalSDP);
          await navigator.clipboard.writeText(compressed);
          alert("SDP –æ—Ñ—Ñ–µ—Ä —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞!");
        } catch (err) {
          console.error("–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è:", err);
          alert("–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è: " + err.message);
        }
      }

      async function pasteCompressedAnswer() {
        const compressedSdrAnswer = document.getElementById("sdpAnswer").value;
        if (!compressedSdrAnswer) {
          alert("–í—Å—Ç–∞–≤—å—Ç–µ SDP answer –æ—Ç –ë–æ–±–∞");
          return;
        }

        try {
          const answerSdp = await SDPCompressor.decompressSDP(
            compressedSdrAnswer
          );

          await peerConnection.setRemoteDescription({
            type: "answer",
            sdp: answerSdp,
          });

          document.getElementById("connectionStatus").innerHTML +=
            "<p>‚úÖ SDP answer –ø—Ä–∏–º–µ–Ω–µ–Ω! –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è...</p>";
          console.log("‚úÖ Remote description —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
        } catch (err) {
          alert("–û—à–∏–±–∫–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è SDP answer: " + err.message);
          console.error("‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ remote description:", err);
        }
      }
    </script>
  </body>
</html>
